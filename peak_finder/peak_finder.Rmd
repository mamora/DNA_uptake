---
title: "peak_finder"
author: "Marcelo Mora"
date: "7 de junio de 2017"
output: html_document
---


```{r setup, include=FALSE}
# Set the path of the working directory; 
knitr::opts_knit$set(root.dir = '~/DNA_uptake')

```



Our data consists in peaks of coverage that increase and decrease per genomic position depending on the amount of DNA taken up per position by the bacteria. We have sequences the amount of periplamic DNA from Haemophilus influenzae competents cells that have taken up sheared input DNA fragments from two different average sizes (0.25kb and 6kb). In the samples that took up the 0.25kb average fragments, this groups of positions that have a lot of coverage, product of DNA uptake, have the shape of peaks.

The objective is to estimate the exact genomic positions that represent the highest point of each of these uptake peaks.

The approach taken is to use a Peakfinder script adapted from:

[link]http://stats.stackexchange.com/questions/36309/how-do-i-find-peaks-in-a-dataset

The function described in the link depends on two parameters "w" and "span".  As explained on the webpage, the function works by smoothing the data  to then find local peaks by comparing local maxima with the smoothed points. By changing these parameters (w = 200, span = 0.02), I was able to optimize the function finding each local peak within the first 10 kb of the genome. 

*WARNING*

This script cannot be used, as described in the webpage, to search the entire genome. The script will behave worse, the longer the fragment is fed to the script.

To solve this I will:

1. break down the genome into 10kb pieces with 2kb overlaps.
2. Run a modified version of the script
3. generate 2 lists: one with all tentative peaks including overlaps, and another list with tentative peaks excluding overlaping regions 

image ![](C:/Users/marcelo/Dropbox/uptake/task_list_marcelo/peak_finder/peak_finder_post/overlap2.png)

4. Edges between each overlaping region will be compared in both lists to search for posible edge effects. If an edge effect is found then it will be corrected

See below figures to understand posible edge effects:


There are three possible situations that can happen if the split is located near an uptake peak



1. peaks are called on opposite sites of the split, close to the edge in each chunck. Since this areas are omitted (grey squares in the plot) then the final list will not include a peak at that position.

2. peaks are called on opposite sites away from the split, far away from the edge in each chunck. In this case the final lost will include 2 peaks very close to each other, instead of one. 

3. peaks are called at the same site of the split, far away from the edge in one chunck and close to the edge in the other. In this case only one peak will be considered in the list.

From this 3 scenarios point 1 and 2 will have to be dealed with checking the lists manually

image ![](C:/Users/marcelo/Dropbox/uptake/task_list_marcelo//peak_finder/peak_finder_post/merge.png)


# Load the data and packages

```{r}

library(ggplot2)

uptake<- read.csv("./datasets/uptake_recal.csv") #read file with positions and ratios (created in Ve4_Josh_task.R)

source("./helper_functions/peak_finder_functions.R")


```


# Split the genome into 10kb chunks but using 2kb overlapping regions in the chuncks (14kb in total).

```{r}

x<- split_pos(uptake)   #split the uptake file for positions
y<- split_ratio(uptake) #split the uptake file for ratios



```

## Set peakfinder parameters

```{r}
#careful DO NOT MESS WITH THE PARAMETERS
w = 200 #parameter  w = 200

span = 0.02 #parameter span = 0.02

cut = 0.2 #minimum uptake ratio to be removed


```



## list of peaks without overlaping regions 

```{r}

h1<- c() 
h2<- c()

peaks.overlap<- data.frame(pos = h1, re.ratio = h2)

for(i in 1:191)
{
  h<- peakfinder(x[[i]], y[[i]], w, span, cut)  #run peakfinder 
  end<- length(x[[i]])  #get the size of each chunck
  peaks1<- data.frame(pos = h$pos, re.ratio = h$ratio) # dataframe of positions and ratios
  g1<- x[[i]][2001:(end - 2000)]  #positions without overlaps
  g2<- which(peaks1$pos %in% g1) #which peaks are located in the previous range of positions
  peaks2<- peaks1[g2,] #get those peaks
  peaks.overlap<- rbind(peaks.overlap, peaks2) #make a dataframe with all peaks excluding overlaps
}

write.csv(peaks.overlap, "./datasets/peak.overlap.csv")

```

## lis of peaks with overlaping regions

```{r}
#create empty vectors to make the loop run
h1<- c() 
h2<- c()


for(i in 1:191)
{
  h<- peakfinder(x[[i]], y[[i]], w, span, cut)  #run peakfinder 
  h1<- c(h1,h$pos)
  h2<- c(h2,h$ratio)  
}

peak.list.all<- data.frame(pos = h1, ratio = h2) #make a dataframe with peaks position and ratio

write.csv(peaks.list.all, "./datasets/peak.list.all.csv")

```

