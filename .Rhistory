seqLogo(p)
par(mfcol= c(2,1));
seqLogo2(t(x));
seqLogo(p)
dev.off()
par(mfcol= c(2,1))
seqLogo2(t(x))
seqLogo(p)
par(mfcol= c(2,1))
seqLogo(p)
seqLogo2(t(x))
dev.off()
par(mfcol= c(2,1))
png(filename="C:/Users/marcelo/Documents/DNA_uptake/Figure_1_logos/motifs.png", width = 900, height = 600, units = "px")
seqLogo(p)
seqLogo2(t(x))
dev.off()
seqLogo
seqLogo2()
seqLogo2
png(filename="C:/Users/marcelo/Documents/DNA_uptake/Figure_1_logos/genomic_motifs.png", width = 900, height = 500, units = "px")
seqLogo(p)
dev.off()
png(filename="C:/Users/marcelo/Documents/DNA_uptake/Figure_1_logos/uptake_motif.png", width = 900, height = 500, units = "px")
seqLogo2(t(x))
dev.off()
overlap<- 1999
length(uptake$pos)/10000 #check in how many parts I can split the genome. I will splitthe genome in 20 parts
abs(length(uptake$pos)/10000) #check in how many parts I can split the genome. I will splitthe genome in 20 parts
int(length(uptake$pos)/10000) #check in how many parts I can split the genome. I will splitthe genome in 20 parts
integer(length(uptake$pos)/10000) #check in how many parts I can split the genome. I will splitthe genome in 20 parts
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
diff
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
last.chunck
pos.l$`1`<- c((pos.l$`191`[(length(pos.l$`191`)- overlap) :length(pos.l$`191`)],pos.l$`1`,(pos.l$`2`[1]:(pos.l$`2`[1]+ overlap)] )
#make a list of the split genome with 2000bp overlaps
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
# same for ratios
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
str(ratio.l[191])
pos.l$`1`<- c((pos.l$`191`[(length(pos.l$`191`)- overlap) :length(pos.l$`191`)],pos.l$`1`,(pos.l$`2`[1]:(pos.l$`2`[1]+ overlap)] )
pos.l2<- pos.l
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
pos.l2<- pos.l
ratio.l2<- ratio.l
split_genome<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
pos.l2<- pos.l
ratio.l2<- ratio.l
#make a list of the split genome with 2000bp overlaps
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
# same for ratios
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
}
str(pos.l)
str(pos.l2)
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
# same for ratios
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
str(pos.l)
str(pos.l2)
split_genome<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
pos.l2<- pos.l
ratio.l2<- ratio.l
#make a list of the split genome with 2000bp overlaps
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
# same for ratios
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
return(pos,l2, ratio.l2)
}
split_genome(uptake)
new.list<- mapply(c, pos.l2, ratio.l2, SIMPLIFY=FALSE)
str(new.list)
list3 = apply(data.frame( pos.l2, ratio.l2) , 1 , unlist )
length(pos.l2)
list<- c()
new.list<- c()
for(i in 1:length(pos.l2)){
chunck<- data.frame( pos.l2[i], ratio.l2[i])
new.list[[paste0("element", i)]] <- chunck
}
new.list
split_genome<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
pos.l2<- pos.l
ratio.l2<- ratio.l
#make a list of the split genome with 2000bp overlaps
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
# same for ratios
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
################# loop to merge both in a dataframe#####################
for(i in 1:length(pos.l2)){
chunck<- data.frame( pos.l2[i], ratio.l2[i])
new.list[[paste0("element", i)]] <- chunck
}
return(new.list)
#end of function
}
split_genome(uptake)
#create empty vectors to make the loop run
h1<- c()
h2<- c()
h3<- c()
peaks.overlap<- data.frame(pos = h1, re.ratio = h2)
w = 200 #parameter  w = 200
span = 0.02 #parameter span = 0.02
str(new.list)
new.list[[1]][1]
new.list[[1]][2]
new.list[[1]][3]
i = 1
h<- test(new.list[[i]][1], new.list[[i]][2], w, span, cut =0.2)
new.list[[i]][1]
new.list[[i]][2]
h<- test(new.list[[i]][1], new.list[[i]][2], w, span, cut =0.2)
h<- test(new.list[[1]][1], new.list[[1]][2], w, span, cut =0.2)
str(new.list)
x = new.list[[i]][1]
y = new.list[[i]][2]
h<- test(x,y, w, span, cut = 0.2)
peakfinder <- function(x , y, w, span, cut) {
peaks <- argmax(x, y, w=w, span=span)
tem <- peaks[[1]] # add numbers of position to a vector instead of a list
peaks[[4]]<- uptake$ratio[tem]  #get uptake ratio of positions with peaks
trim<- which(peaks[[4]] >= cut) #eliminate positions with less than 0.5
pos<- peaks$x[trim]
ratio<- uptake$ratio[pos]
peak.data<- data.frame( pos = pos, ratio = ratio)
}
h<- peakfinder(x,y, w, span, cut = 0.2)
y
y = as.numeric(new.list[[i]][2])
y = unlist(new.list[[i]][2])
y
x
x = c(new.list[[i]][1])
x
y = c(new.list[[i]][2])
h<- peakfinder(x,y, w, span, cut = 0.2)
h1<- data.frame(x = new.list[[i]][1], y = new.list[[i]][2])
h<- peakfinder(h1$x,h1$y, w, span, cut = 0.2)
str(uptake)
peakfinder <- function(x , y, w, span, cut) {
peaks <- argmax(x, y, w=w, span=span)
tem <- peaks[[1]] # add numbers of position to a vector instead of a list
peaks[[4]]<- uptake$re.ratio[tem]  #get uptake ratio of positions with peaks
trim<- which(peaks[[4]] >= cut) #eliminate positions with less than 0.5
pos<- peaks$x[trim]
ratio<- uptake$re.ratio[pos]
peak.data<- data.frame( pos = pos, ratio = ratio)
}
h1<- data.frame(x = new.list[[i]][1], y = new.list[[i]][2])
h<- peakfinder(h1$x,h1$y, w, span, cut = 0.2)
h<- peakfinder(h1$x,h1$y, w, span, cut = 0.2)
h1<- data.frame(x = new.list[[i]][1], y = new.list[[i]][2])
h<- peakfinder(h1$x, h1$y, w, span, cut = 0.2)
h1<- data.frame(x = new.list[[i]][1], y = new.list[[i]][2])
h1
argmax(h1$x, h1$y, w, span)
as.numeric(new.list[[i]][1])
h1
i = 1
new.list[[i]]$X[i]
str(h1)
new.list[[i]]$x[i]
new.list[[i]]$X1
h<- peakfinder(new.list[[i]]$X1, new.list[[i]]$X1.1, w, span, cut = 0.2)
new.list[[i]]$[1]
for(i in 1:length(pos.l2)){
chunck<- data.frame( pos = pos.l2[i], ratio = ratio.l2[i])
new.list[[paste0("element", i)]] <- chunck
}
str(new.list)
new.list$element1
new.list[[1]]$
for(i in 1:191)
whereami <- "C:/Users/marcelo/Dropbox/uptake/task_list_marcelo/" # Where these files are located
setwd(whereami)
uptake<- read.csv("datasets/uptake_recal.csv") #read file with positions and ratios (created in Ve4_Josh_task.R)
split_genome<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
pos.l2<- pos.l
ratio.l2<- ratio.l
#make a list of the split genome with 2000bp overlaps
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
# same for ratios
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
################# loop to merge both in a dataframe#####################
#end of function
}
#original peakfinder script
argmax <- function(x, y, w=1, ...) {
require(zoo)
n <- length(y)
y.smooth <- loess(y ~ x, ...)$fitted
y.max <- rollapply(zoo(y.smooth), 2*w+1, max, align="center")
delta <- y.max - y.smooth[-c(1:w, n+1-1:w)]
i.max <- which(delta <= 0) + w
list(x=x[i.max], i=i.max, y.hat=y.smooth)
}
#modified peakfinder script
peakfinder <- function(x , y, w, span, cut) {
peaks <- argmax(x, y, w=w, span=span)
tem <- peaks[[1]] # add numbers of position to a vector instead of a list
peaks[[4]]<- uptake$re.ratio[tem]  #get uptake ratio of positions with peaks
trim<- which(peaks[[4]] >= cut) #eliminate positions with less than 0.5
pos<- peaks$x[trim]
ratio<- uptake$re.ratio[pos]
peak.data<- data.frame( pos = pos, ratio = ratio)
}
split<- split_genome(uptake)
split_pos<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
pos.l2<- pos.l
#make a list of the split genome with 2000bp overlaps
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
#end of function
}
split_ratio<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
ratio.l2<- ratio.l
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
split_ratio<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
ratio.l2<- ratio.l
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
}
split_ratio<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
ratio.l2<- ratio.l
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
}
x<- split_pos(uptake)
y<- split_ratio(uptake)
h1<- c()
h2<- c()
h3<- c()
peaks.overlap<- data.frame(pos = h1, re.ratio = h2)
w = 200 #parameter  w = 200
span = 0.02 #parameter span = 0.02
i = 1
x<- split_pos(uptake)   #split the uptake file for positions
y<- split_ratio(uptake) #split the uptake file for ratios
split_ratio<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
ratio.l2<- ratio.l
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
################# loop to merge both in a dataframe#####################
return(ratio.l2)
#end of function
}
split_ratio<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
ratio.l<- split(uptake$re.ratio, rep(1:191, p)) # split the ratios of the genome in another list
ratio.l2<- ratio.l
for (i in 2:190){
a<- i + 1
b<- i - 1
ratio.l2[[i]]<- c(ratio.l[[b]][(10000 - overlap):10000],ratio.l[[i]],(ratio.l[[a]][1:(1+ overlap)]))
}
#circularize
ratio.l2[[1]]<- c(ratio.l[[191]][(14490 - overlap):14490],ratio.l[[1]],(ratio.l[[2]][1:(1+ overlap)]))
ratio.l2[[191]]<- c(ratio.l[[190]][(10000 - overlap):10000],ratio.l[[191]],(ratio.l[[1]][1:(1+ overlap)]))
################# loop to merge both in a dataframe#####################
return(ratio.l2)
#end of function
}
split_pos<- function(uptake){
overlap<- 1999
diff<- (length(uptake$pos) - 10000*191) #calculating the length of the last chunk
last.chunck<- (10000 + (length(uptake$pos) - 10000*191)) #making a vector of the size of the last chunck
p<- rep(10000,190) #make a vector of 19 times 100000
p<- c(p,(last.chunck))  # make a vector of the all the chunck sizes
pos.l<- split(uptake$pos, rep(1:191, p)) #split the positions of the genome in one list
pos.l2<- pos.l
#make a list of the split genome with 2000bp overlaps
for (i in 2:190){
a<- i + 1
b<- i - 1
pos.l2[[i]]<- c((pos.l[[b]][10000]- overlap):(pos.l[[b]][10000]),pos.l[[i]],(pos.l[[a]][1]:(pos.l[[a]][1]+ overlap)))
}
#circularize
pos.l2[[1]]<- c((pos.l[[191]][14490]- overlap):(pos.l[[191]][14490]),pos.l[[1]],(pos.l[[2]][1]:(pos.l[[2]][1]+ overlap)))
pos.l2[[191]]<- c((pos.l[[190]][10000]- overlap):(pos.l[[190]][10000]),pos.l[[191]],(pos.l[[1]][1]:(pos.l[[1]][1]+ overlap)))
#end of function
return(pos.l2)
}
x<- split_pos(uptake)   #split the uptake file for positions
y<- split_ratio(uptake) #split the uptake file for ratios
h<- peakfinder(x[i], y[i], w, span, cut = 0.2)
h<- peakfinder(x[[i]], y[[i]], w, span, cut = 0.2)
length(x[[i]])
str(h)
peaks1<- data.frame(pos = h$pos, re.ratio = h$ratio)
g1<- pos.l2[[i]][2001:(end - 2000)]
g1<- x[[i]][2001:(end - 2000)]
str(x)
g1<- x[[i]][2001:(end - 2000)]
g1<- as.numeric(x[[i]][2001:(end - 2000)])
x[[i]][2001]
(end - 2000)
end
end<- length(x[[i]])
end
nd
end
g1<- x[[i]][2001:(end - 2000)]
g1
x[[1]][1]
x[[1]]
g2<- which(peaks1$pos %in% g1)
g2
g1
b<- 3
pos.l[[b]][10000]
x[[i]][2001:(end - 2000)]
g2<- which(peaks1$pos %in% g1)
g2
peaks2<- peaks1[g2,]
peaks2
pos.l2[[1]][end - 2000]
x[[1]][end - 2000]
x[[1]][end]
x[[2]][1]
x[[2]][2001]
x[[2]][2001]
g2
peaks2
whereami <- "~/DNA_uptake" # Where these files are located
setwd(whereami)
knitr::opts_knit$set(root.dir = '~/DNA_uptake')
knitr::opts_knit$set(root.dir = '~/DNA_uptake')
knitr::opts_knit$set(root.dir = '~/DNA_uptake')
source("~/helper_functions/peak_finder_functions.R")
source("./helper_functions/peak_finder_functions.R")
whereami <- "~/DNA_uptake/" # Where these files are located
setwd(whereami)
list.files(whereami) #see files in directory
