---
title: "NP uptake ratios"
author: "Marcelo Mora"
date: "1 de junio de 2017"
output: html_document
---

#Goal# 

To generate uptake ratios for small and large fragment data for NP donor DNA samples



First I need to load the samples names to know which sample is which

```{r}

# Name the path of the working directory; 
### Set the path from your computer ###
whereami <- "C:/Users/marcelo/Dropbox/documentos phd/experiments/virtual experiments/Vex4/tutorialRjosh/Tutorial1/" # Where these files are located

# Set working directory
setwd(whereami)


#load samples names
periDNA<- read.table("datasets/periDNA.txt", header=TRUE, comment.char="")


View(periDNA)

```


Now I need to load the raw reads from NP data

```{r}

# All this dataframes are available by request. Contact redfield@zoology.ubc.ca

# read table with raw reads of all rdnp samples
NP_raw.reads <- read.table("datasets/rdgg.depth.txt.gz", comment.char="", header=TRUE)

str(NP_raw.reads) #check out everything is ok


```


Next step is to filter only reads from NP 

```{r}

NP.only.raw.reads <- NP_raw.reads[grep("NC_009567.1", NP_raw.reads$X.chr), 1:dim(NP_raw.reads)[2]] #get only uptake ratios of reads aligned to NP


View(NP.only.raw.reads)

```

Check out coverage at input

```{r}

p <- ggplot() +
  geom_point(aes(x = UP14, y = UP16), data = NP.only.raw.reads, shape = ".", size = 1, colour = "dark blue")+
  scale_y_continuous(limits = c(0,1900), expand = c(0, 0))+
  scale_x_continuous(limits = c(0,1900), expand = c(0, 0))+
  labs(x = "read depth in large fragments input", y = "reads depth in small fragment input") +
  ggtitle(" Read depth of input fragments analysis for NP") +
  theme_bw()+
        theme(plot.title = element_text(size = rel(1.2), face = "bold", vjust = 1.5))

p


```



Next, I need to make the normalized reads dataset. For that I need the total number of reads per sample.

```{r}

# read table with several summary stats  
flags <- read.table("C:/Users/marcelo/Dropbox/uptake/Everything_else/summary/flags.summary.txt", header=FALSE)
# load column names which are the headers of the dataframe 
colnames(flags) <- c("sample", "reads", "dups", "mapped", 
                     "paired", "read1", "read2", "proper", 
                     "pair_map", "singletons", "translocations", "transloc_hiqual", 
                     "chrA", "startA", "endA", "reads_mappedA", 
                     "bases_coveredA", "total_basesA", "frac_coveredA",
                     "chrB", "startB", "endB", "reads_mappedB", 
                     "bases_coveredB", "total_basesB", "frac_coveredB"
)


View(flags)


```


##Normalize the raw reads to depth per millon reads##


```{r}

NP.only.depth.per.millon <- NP.only.raw.reads

NP.only.depth.per.millon$UP04<- (NP.only.raw.reads$UP04 *1e+6)/flags$reads[8]

NP.only.depth.per.millon$UP05<- (NP.only.raw.reads$UP05 *1e+6)/flags$reads[10]

NP.only.depth.per.millon$UP06<- (NP.only.raw.reads$UP06 *1e+6)/flags$reads[12]

NP.only.depth.per.millon$UP10<- (NP.only.raw.reads$UP10 *1e+6)/flags$reads[20]

NP.only.depth.per.millon$UP11<- (NP.only.raw.reads$UP11 *1e+6)/flags$reads[22]

NP.only.depth.per.millon$UP12<- (NP.only.raw.reads$UP12 *1e+6)/flags$reads[24]

NP.only.depth.per.millon$UP12<- (NP.only.raw.reads$UP12 *1e+6)/flags$reads[24]

NP.only.depth.per.millon$UP14<- (NP.only.raw.reads$UP14 *1e+6)/flags$reads[28]

NP.only.depth.per.millon$UP16<- (NP.only.raw.reads$UP16 *1e+6)/flags$reads[32]

View(NP.only.depth.per.millon)


```



##Calculate Uptake ratios##



```{r}

UP10<- NP.only.depth.per.millon$UP10/(NP.only.depth.per.millon$UP16)

UP11<- NP.only.depth.per.millon$UP11/(NP.only.depth.per.millon$UP16)

UP12<- NP.only.depth.per.millon$UP12/(NP.only.depth.per.millon$UP16)



UP04<- NP.only.depth.per.millon$UP04/(NP.only.depth.per.millon$UP14)

UP05<- NP.only.depth.per.millon$UP05/(NP.only.depth.per.millon$UP14)

UP06<- NP.only.depth.per.millon$UP06/(NP.only.depth.per.millon$UP14)

str(NP.only.depth.per.millon)



NP.uptake.ratio<- data.frame(pos = NP.only.depth.per.millon$pos, UP04 = UP04, UP05 = UP05, UP06 = UP06, UP10 = UP10, UP11 = UP11, UP12 = UP12)


View(NP.uptake.ratio)

##################calculate mean of the three replicates#######################
NP.uptake.ratio$ratio_long<- apply(NP.uptake.ratio[,2:4], 1, mean)

NP.uptake.ratio$ratio_small<- apply(NP.uptake.ratio[,5:7], 1, mean)
###############################################################################

flag_small<-  NP.only.raw.reads$UP16[1:length(NP.only.raw.reads$UP16)]>=10  #make the flag vector of low input positions


flag_large<-  NP.only.raw.reads$UP14[1:length(NP.only.raw.reads$UP14)]>=10  #make the flag vector of low input positions


NP.uptake.ratio$flag_small<- flag_small

NP.uptake.ratio$flag_large<- flag_large


```


##Calculate uptake ratios adding a pseudocount (correcting for missing positions)##

Adding a pseudocount is requires in some analysis, such as the peak finder analysis, where the missing values are not tolerated. This uptake ratio with pseudocount will not be reported as the true uptake ratio per position.  


```{r}

UP10.p<- NP.only.depth.per.millon$UP10/(NP.only.depth.per.millon$UP16 +1)

UP11.p<- NP.only.depth.per.millon$UP11/(NP.only.depth.per.millon$UP16 +1 )

UP12.p<- NP.only.depth.per.millon$UP12/(NP.only.depth.per.millon$UP16 +1)



UP04.p<- NP.only.depth.per.millon$UP04/(NP.only.depth.per.millon$UP14 +1)

UP05.p<- NP.only.depth.per.millon$UP05/(NP.only.depth.per.millon$UP14 +1)

UP06.p<- NP.only.depth.per.millon$UP06/(NP.only.depth.per.millon$UP14 +1)



NP.pseudo.uptake.ratio<- data.frame(pos = NP.only.depth.per.millon$pos, UP04.p = UP04.p, UP05.p = UP05.p, UP06.p = UP06.p, UP10.p = UP10.p, UP11.p = UP11.p, UP12.p = UP12.p)

NP.uptake.ratio$pseudo_ratio_long<- apply(NP.pseudo.uptake.ratio[,2:4], 1, mean)

NP.uptake.ratio$pseudo_ratio_small<- apply(NP.pseudo.uptake.ratio[,5:7], 1, mean)


write.csv(NP.uptake.ratio, file="C:/Users/marcelo/Dropbox/uptake/Everything_else/Marcelo scripts and files/NP_maps/NP.uptake.ratio.csv", quote=FALSE) #save file



```

